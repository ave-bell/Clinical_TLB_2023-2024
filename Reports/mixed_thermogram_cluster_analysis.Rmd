---
title: "Mixed Thermogram Cluster Analysis"
author: "Avery Bell"
date: "2024-02-26"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(clinicalDSCdata)
library(fpc)
library(cluster)
library(factoextra)
library(ClusterR)
```

## Introduction

The report represents the results of a cluster analysis on the Fritzler thermograms present in the Mixed Thermogram data set. The goal of this analysis was to utilize unsupervised techniques to determine if thermogram characteristics differ by disease.Table 1 represents the diseases and thermogram frequencies included in this analysis.

### Table 1: Disease Groups and Frequencies
```{r}

codes <- c('SCL', 'RAF', 'JOF', 'ERA', 'ROF', 'CCP', 'CEN', 'CHR', 'S70', 'LUF') #LUF


cluster_df <- MixedThermograms %>%
  filter(code %in% codes)

graph_df <- cluster_df

counts <- cluster_df %>% 
  group_by(DiseaseGroup) %>%
  summarize(Count = n())

knitr::kable(counts)
```


It can be seen that a broad range of diseases are present in this analysis with a mix of frequencies, ranging from 9 - 50. Figure 1 plots each thermogram curve according to it's disease group. It can be seen that the thermograms differ by disease, but also contain variability in presentation within a disease. This may impact a clustering algorithm's ability to identify differences between curves that are distinct across diseases.

### Figure 1: Thermograms by Diesease Group
```{r}
mixed_long <- pivot_longer(
                           cluster_df, 
                           cols = T45:T90,
                           names_to = "Temperatures",
                           values_to = "DSP"
                            )

mixed_long <- mixed_long %>% 
  mutate(Temperatures = as.numeric(str_remove(Temperatures, "T")))

ggplot(mixed_long, aes(x = Temperatures))+
  geom_line(aes(y = DSP, group = sampleID))+
  facet_wrap( . ~ DiseaseGroup ) 
```

### Methods

Divisive and agglomerative hierarchical clustering was used to analyze these thermogram curves. Distances between samples were calculated using Gower Distance. The specific excess heat capacities observed from 50 - 80 C were used to train the models. The average silhouette width was calculated for k = 2,...,10 and was used to evaluate cluster <something>. The values of k = 2, ..., 10 were uses because 2 is the minimum number of clusters that can be used in an analysis, and there are 10 disease groups present in the data used. The values for k for the divisive and agglomerative method with the lowest average silhouette width observed were used were explored and visualized.

### Results

The results for k = 2, ..., 10 for the divisive and agglomerative analysis are shown in table 2. For agglomerative clustering, the ideal number of clusters is 5, and for divisive clustering the ideal number of clusters is 6. 

```{r}

cluster_df <- MixedThermograms %>%
  filter(code %in% codes)%>% 
  select(c(3, T50:T83))

labs <- MixedThermograms %>% 
  filter(code %in% codes)%>% 
  select(DiseaseGroup) 

labs_1 <- as.factor(labs$DiseaseGroup)


labs <- as.numeric(as.factor(labs$DiseaseGroup))

cluster_df <- column_to_rownames(cluster_df, 'sampleID')

# cluster_df_1_1 <- t(cluster_df)
# 
# cluster_df_1_2 <- diff(cluster_df_1_1)
# 
# cluster_df_1 <- as.data.frame(t(cluster_df_1_2))

gower.dist <- daisy(cluster_df, metric = 'gower')
#class(gower.dist)

# Using "complete" linkage - agglomerative
agg_clust_c <- hclust(gower.dist, method = "complete")

# Using "complete" linkage - divisive
divisive_clust <- diana(as.matrix(gower.dist), 
                        diss = TRUE, keep.diss = TRUE)


result_df <- data.frame(k = numeric(), purity = numeric(), silhouette = numeric(), twss = numeric())

for (k in 2:length(unique(labs))) {
  
  # Agglomerative clustering
  clusters_agg <- cutree(agg_clust_c, k = k)
  
  # Divisive clustering
  clusters_div <- cutree(divisive_clust, k = k)
  
  # Calculate cluster statistics for agglomerative clustering
  cluster_stats_agg <- cluster.stats(gower.dist, clusters_agg)
  
  # Calculate purity for agglomerative clustering
  purity_result_agg <- external_validation(clusters_agg, labs, method = "purity")
  
  # Calculate silhouette for agglomerative clustering
  silhouette_result_agg <- cluster_stats_agg$avg.silwidth
  
  # Calculate TWSS for agglomerative clustering
  twss_result_agg <- cluster_stats_agg$within.cluster.ss
  
  # Calculate cluster statistics for divisive clustering
  cluster_stats_div <- cluster.stats(gower.dist, clusters_div)
  
  # Calculate purity for divisive clustering
  purity_result_div <- external_validation(clusters_div, labs, method = "purity")
  
  # Calculate silhouette for divisive clustering
  silhouette_result_div <- cluster_stats_div$avg.silwidth
  
  # Calculate TWSS for divisive clustering
  twss_result_div <- cluster_stats_div$within.cluster.ss
  
  # Combine all results into a single dataframe for agglomerative clustering
  cluster_results_agg <- data.frame(k = k, method = "agglomerative", 
                                    purity = purity_result_agg, silhouette = silhouette_result_agg, 
                                    twss = twss_result_agg)
  
  # Combine all results into a single dataframe for divisive clustering
  cluster_results_div <- data.frame(k = k, method = "divisive", 
                                    purity = purity_result_div, silhouette = silhouette_result_div, 
                                    twss = twss_result_div)
  
  # Append the results to result_df
  result_df <- rbind(result_df, cluster_results_agg, cluster_results_div)
  
}



rclusters <- cutree(agg_clust_c, k = 9)
# Create a contingency table
contingency_table <- table(Disease = labs_1, Clusters = rclusters)

# Calculate proportions
proportions <- prop.table(contingency_table, margin = 1)
```

### Table 2: Clustering Metrics Results
```{r}
result_df %>%
  select(k, method, silhouette) %>% 
  arrange(silhouette) %>%
  head(5) %>%
  knitr::kable()
```

Table 3 and figure 2 represent the results for the top agglomerative results. Table 3 demonstrates that there is a large mixture of different diseases in clusters 1 and 3, and sparse clusters in groups 2, 4, and 5. Figure 2 shows that the thermograms have been grouped by shape. There is a potential outlier in the data present in in cluster 4, as the curve so so distinct that it is grouped on its own.

### Table 3: Porportions of each Disease across Agglomerative Clusters
```{r}
groups <- 5
rclusters <- cutree(agg_clust_c, k = groups)
# Create a contingency table
contingency_table <- table(Disease = labs_1, Clusters = rclusters)

# Calculate proportions
round(prop.table(contingency_table, margin = 1), digits = 2)

```



### Figure 2: Top Agglomerative Result

```{r}
clust_graph <- cbind(graph_df, rclusters)

clust_graph <- rownames_to_column(clust_graph, "sample_id")

clust_graph_1 <- pivot_longer(
                           clust_graph, 
                           cols = T50:T83,
                           names_to = "Temperatures",
                           values_to = "DSP"
                            )

clust_graph_2 <- clust_graph_1 %>% 
  mutate(Temperatures = as.numeric(str_remove(Temperatures, "T")))

ggplot(clust_graph_2, aes(x = Temperatures))+
  geom_line(aes(y = DSP, group = sample_id, color = code))+
  facet_wrap( . ~ rclusters ) 




```

Table 4 and figure 3 represent the results for the top divisive results. Table 4 demonstrates that there is a large mixture of different diseases in clusters 1, 2, 4, and 5 and sparse clusters in groups 3 and 6. Figure 3 shows that the thermograms have been grouped by shape. There are potential outliers in the data present in in clusters 3 and 6, with the curve in cluster 3 also being grouped by itself in the agglomerative clustering.


### Table 4: Porportions of each Disease across Divisive Clusters
```{r}
groups <- 6
rclusters <- cutree(divisive_clust, k = groups)
# Create a contingency table
contingency_table <- table(Disease = labs_1, Clusters = rclusters)

# Calculate proportions
round(prop.table(contingency_table, margin = 1), digits = 2)
```



### figure 3: top divisive result


```{r}

clust_graph <- cbind(graph_df, rclusters)

clust_graph <- rownames_to_column(clust_graph, "sample_id")

clust_graph_1 <- pivot_longer(
                           clust_graph, 
                           cols = T50:T83,
                           names_to = "Temperatures",
                           values_to = "DSP"
                            )

clust_graph_2 <- clust_graph_1 %>% 
  mutate(Temperatures = as.numeric(str_remove(Temperatures, "T")))

ggplot(clust_graph_2, aes(x = Temperatures))+
  geom_line(aes(y = DSP, group = sample_id, color = code))+
  facet_wrap( . ~ rclusters ) 



```

Unsupervised methods are sensitive to the data they are trained on. Due to this, the two outlier curves present in the above clusterings may have a strong effect on the results. The above methodology was repeated after removing those two thermograms.


# Removing outlier curves
```{r}
cluster_df <- MixedThermograms %>%
  filter(sampleID != 'SCL25' & sampleID != 'S70F5') %>% 
  filter(code %in% codes)%>% 
  select(c(3, T50:T83))

graph_df <- MixedThermograms %>%
  filter(sampleID != 'SCL25' & sampleID != 'S70F5') %>% 
  filter(code %in% codes)


labs <- MixedThermograms %>% 
  filter(sampleID != 'SCL25' & sampleID != 'S70F5') %>% 
  filter(code %in% codes)%>% 
  select(DiseaseGroup) 

labs_1 <- as.factor(labs$DiseaseGroup)


labs <- as.numeric(as.factor(labs$DiseaseGroup))

cluster_df <- column_to_rownames(cluster_df, 'sampleID')

# cluster_df_1_1 <- t(cluster_df)
# 
# cluster_df_1_2 <- diff(cluster_df_1_1)
# 
# cluster_df_1 <- as.data.frame(t(cluster_df_1_2))

gower.dist <- daisy(cluster_df, metric = 'gower')
#class(gower.dist)

# Using "complete" linkage - agglomerative
agg_clust_c <- hclust(gower.dist, method = "complete")

# Using "complete" linkage - divisive
divisive_clust <- diana(as.matrix(gower.dist), 
                        diss = TRUE, keep.diss = TRUE)


result_df <- data.frame(k = numeric(), purity = numeric(), silhouette = numeric(), twss = numeric())

for (k in 2:length(unique(labs))) {
  
  # Agglomerative clustering
  clusters_agg <- cutree(agg_clust_c, k = k)
  
  # Divisive clustering
  clusters_div <- cutree(divisive_clust, k = k)
  
  # Calculate cluster statistics for agglomerative clustering
  cluster_stats_agg <- cluster.stats(gower.dist, clusters_agg)
  
  # Calculate purity for agglomerative clustering
  purity_result_agg <- external_validation(clusters_agg, labs, method = "purity")
  
  # Calculate silhouette for agglomerative clustering
  silhouette_result_agg <- cluster_stats_agg$avg.silwidth
  
  # Calculate TWSS for agglomerative clustering
  twss_result_agg <- cluster_stats_agg$within.cluster.ss
  
  # Calculate cluster statistics for divisive clustering
  cluster_stats_div <- cluster.stats(gower.dist, clusters_div)
  
  # Calculate purity for divisive clustering
  purity_result_div <- external_validation(clusters_div, labs, method = "purity")
  
  # Calculate silhouette for divisive clustering
  silhouette_result_div <- cluster_stats_div$avg.silwidth
  
  # Calculate TWSS for divisive clustering
  twss_result_div <- cluster_stats_div$within.cluster.ss
  
  # Combine all results into a single dataframe for agglomerative clustering
  cluster_results_agg <- data.frame(k = k, method = "agglomerative", 
                                    purity = purity_result_agg, silhouette = silhouette_result_agg, 
                                    twss = twss_result_agg)
  
  # Combine all results into a single dataframe for divisive clustering
  cluster_results_div <- data.frame(k = k, method = "divisive", 
                                    purity = purity_result_div, silhouette = silhouette_result_div, 
                                    twss = twss_result_div)
  
  # Append the results to result_df
  result_df <- rbind(result_df, cluster_results_agg, cluster_results_div)
  
}
```
### table 4: Reclustering Metrics Evaluation

```{r}
result_df %>%
  select(k, method, silhouette) %>% 
  arrange(silhouette) %>%
  head(5) %>%
  knitr::kable()
```


### figure 4: top agglomerative result after reclustering

```{r}
groups <- 7
rclusters <- cutree(agg_clust_c, k = groups)
# Create a contingency table
contingency_table <- table(Disease = labs_1, Clusters = rclusters)

# Calculate proportions
round(prop.table(contingency_table, margin = 1), digits = 2)


clust_graph <- cbind(graph_df, rclusters)

clust_graph <- rownames_to_column(clust_graph, "sample_id")

clust_graph_1 <- pivot_longer(
                           clust_graph, 
                           cols = T50:T83,
                           names_to = "Temperatures",
                           values_to = "DSP"
                            )

clust_graph_2 <- clust_graph_1 %>% 
  mutate(Temperatures = as.numeric(str_remove(Temperatures, "T")))

ggplot(clust_graph_2, aes(x = Temperatures))+
  geom_line(aes(y = DSP, group = sample_id, color = code))+
  facet_wrap( . ~ rclusters ) 



```

### figure 5: top divisive result after reclustering

```{r}
groups <- 4
rclusters <- cutree(divisive_clust, k = groups)
# Create a contingency table
contingency_table <- table(Disease = labs_1, Clusters = rclusters)

# Calculate proportions
round(prop.table(contingency_table, margin = 1), digits = 2)


clust_graph <- cbind(graph_df, rclusters)

clust_graph <- rownames_to_column(clust_graph, "sample_id")

clust_graph_1 <- pivot_longer(
                           clust_graph, 
                           cols = T50:T83,
                           names_to = "Temperatures",
                           values_to = "DSP"
                            )

clust_graph_2 <- clust_graph_1 %>% 
  mutate(Temperatures = as.numeric(str_remove(Temperatures, "T")))

ggplot(clust_graph_2, aes(x = Temperatures))+
  geom_line(aes(y = DSP, group = sample_id, color = code))+
  facet_wrap( . ~ rclusters ) 



```






Chi Square Test ???
```{r}
# Create a contingency table
contingency_table <- table(labs, rclusters)

# Perform chi-square test
chi_square_test <- chisq.test(contingency_table)

# Print the results
print(chi_square_test)

```



### Code Appendix 
```{r, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE, documentation=1}
```

